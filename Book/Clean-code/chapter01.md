# 1. 코드란 ?

- **요구사항을 표현하는 언어**
  - 요구사항을 기계가 이해할 정도로 엄밀하고 정확하고 상세하게 정형화되어야 한다.
  - 고도로 추상화된 언어나 특정 응용 분야 언어로 기술하는 명세도 코드이다.

---

# 2. 나쁜 코드

## 2-1. 좋은 코드는 왜 중요한 걸까?

- 나쁜 코드는 서비스가 계속 추가로 기능을 확장하고, 커질 수록 문제가 발생할 가능성이 높아진다.
- 고치고 싶어도 무수히 많은 코드에서 문제를 발견하기 쉽지 않으며, 사막에서 바늘을 찾는 것과 같다.

## 2-2. 그렇다면 왜 우리는 나쁜 코드를 짜게 된 걸까?

- 제대로 짤 시간이 없다고 생각해서, 서비스 출시에 대한 압박 때문에, 지겨워서 등의 이유가 있다.
- 우리가 이 코드를 나중에 손 보겠다고 다시 돌아와 작업한 경험이 얼마나 있을까 ?
  - 다른 업무로 인해, 바쁘다는 이유, 정치적인 문제로 … 우리는 이 일을 미루고는 한다.
  - 르블랑의 법칙 : “나중은 결코 오지 않는다.”
- 따라서 우리는 **처음 작성할 때부터 좋은 코드를 고려하며 짜는 것이 중요하다.**

---

# 3. 나쁜 코드로 치르는 대가

- 개발 속도를 크게 저하시킨다.
  - 코드 고치고 변경할 때마다 엉뚱한 곳에서 문제가 발생하기 때문에 간단한 변경 조차 쉽지 않다.
  - 나쁜 코드가 시간을 거듭해서 계속 쌓이면서 이를 해결하기가 점점 어려워진다.

## 3-1 원대한 재설계의 꿈

- 시간을 들여 깨끗한 코드를 만드는 노력이 비용을 절감시키며, 전문가로서 살아남는 길이 된다.

## 3-2 태도

- 코드를 엉망으로 잘못 짜는 것은 프로그래머가 전문가 답게 해결하지 못한 것임을 인정하고 받아들여야한다.
- 나쁜 코드의 위험을 이해하지 못하는 **관리자의 말을 그대로 따르는 행동은 전문가답지 못하다.**

## 3-3 원초적 난제

- 모든 프로그래머가 기한을 맞추려면 나쁜 코드를 양산할 수 밖에 없다고 느낀다.
- 하지만 나쁜 코드를 양산하면 후일에 발목이 잡히는건 매한가지다.
- 그렇게 엉망진창인 상태로 인해 작업 속도가 늦어지고, 결국 기한을 놓친다.
- **즉, 빨리 가는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관 뿐이다.**

### 3-4 깨끗한 코드라는 예술?

- 깨끗한 코드와 나쁜 코드를 구분할 줄 안다고 깨끗한 코드를 작성할 수 있는 것은 아니다.
- 나쁜 모듈을 알아보고 그것을 개선할 방안을 떠올려야한다.

### 3-5 깨끗한 코드란?

- 저자는 이 분야에 노련한 사람들의 말을 인용해서 부연 설명을 하는데, 요점은 “**필요한 내용을 담아 한 가지의 역할만을 잘 수행하며 그 기능의 동작에 대한 의도가 보여 읽기 좋은 코드”** 라는 것이 공통적인 의견이다.

---

# 4. 보이스카우트 규칙

“ **캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라”**

- 한 번에 많은 시간을 들일 필요 없이 변수 이름 바꾸기, 함수 나누기, 중복 제거 등이면 충분하다.
- 작더라도 지속적인 개선이 이루어질 수 있도록 노력해야한다.

---

# 5. 프리퀄과 원칙

**[Agile Software Development : Principles, Patterns, and Practices](http://www.yes24.com/Product/Goods/39497990)(PPP, 2002)의 프리퀄**

- 객체 지향 설계 원칙을 설명하고, 전문 개발자들이 사용하는 실무 기법을 소개하는 책

---

# 6. **객체 지향 프로그래밍의 5대(SOLID) 원칙**

**S : SRP(Single Responsibility Principle) : 단일 책임 원칙**

- 한 클래스(=함수)는 하나의 책임만 가져야 한다.

**O** **:** **OCP(Open Closed Principle) : 개방 폐쇄 원칙**

- 소프트웨어 요소는 확장에 열려 있어야 하며 변경에는 닫혀 있어야 한다.

**L** **:** **LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙**

- 상속받은 클래스는 그 부모 클래스를 대체할 수 있어야 한다.

**I** : **ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙**

- 인터페이스를 최대한 작게 분리시킨다.

**D** : **DIP(Dependency Inversion Principle): 의존관계 역전 원칙**

- 추상화에 의존해야 하며, 구체화에 의존하면 안 된다. (의존성 주입은 이 원칙을 따르는 방법 중 하나다.)
