# 알고리즘 성능 평가

## 복잡도(Complex)

- 알고리즘의 성능을 타나내는 척도
  - 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
  - 공간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘 메모리 사용량 분석
- 동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 좋은 알고리즘

## 빅오 표기법(Big-O Notation)

- 가장 빠르게 증가하는 항만 고려하는 표기법

  - 함수의 상한만을 나타내게 된다.

  ex) 연산 횟수 3N³+ 5N²+ 1,000,000인 알고리즘이 있다고 할 때, 빅오표기법에서는 차수가 가장 큰 항만 남기므로 O(N³) 으로 표현
  <img src="https://user-images.githubusercontent.com/77887712/156172234-3bdb3e45-c8c5-4b50-b5df-0b62a4d7f50d.png" width="500px">

## 알고리즘 설계 Tip

- 일반 CPU 기반의 PC에서는 연산 횟수가 5억 이상인 경우
  - C언어를 기준으로 1 ~ 3초 가량 시간이 소요
  - Python을 기준으로 5 ~ 15초 가량 시간이 소요
- 코딩 테스트의 시간 제한은 통상 1 ~ 5초 가량이며, 문제 안에 명시되지 않은 경우 대략 5초정도로 짐작하면 된다.

## 요구사항에 따른 적절한 알고리즘 설계

- 문제에서 가장 먼저 확인해야 하는 부분은 **시간제한(수행시간 요구사항)**
- 시간 제한이 1초인 문제인 경우, 일반적인 설계 기준
  - N의 범위가 500인 경우, 시간 복잡도 O(N³)로 설계
  - N의 범위가 2,000인 경우, 시간 복잡도 O(N²)로 설계
  - N의 범위가 100,000인 경우, 시간 복잡도 O(NlogN)로 설계
  - N의 범위가 10,000,000인 경우, 시간 복잡도 O(N)로 설계

## 알고리즘 문제해결과정

1. 지문 읽기
2. 요구사항(복잡도) 분석
3. 문제 해결 아이디어 찾기
4. 소스 코드 설계 및 코딩

- 문제에 대한 핵심 아이디어를 캐치하면, 간결하게 소스코드를 작성할 수 있는 형태의 문제로 출제되고 있음

## 수행시간 측정 소스코드 예제

```python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드
end_time = time.time() # 측정 종료
print('time : ', end_time - start_time) # 수행시간 출력
```
